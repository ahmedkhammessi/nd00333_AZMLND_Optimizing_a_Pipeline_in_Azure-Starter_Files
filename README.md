# Optimizing an ML Pipeline in Azure

## Overview
This project is part of the Udacity Azure ML Nanodegree.
In this project, we build and optimize an Azure ML pipeline using the Python SDK and a provided Scikit-learn model.
This model is then compared to an Azure AutoML run.

## Summary
- We had initially a dataset stored already in a publicly accessible blob storage containing bank customers data. Thoughout the experince we aim at predicting whether the customers will be intersted in new product by basing the marketing campaign on the most influencing parameter in the dataset.

- The best performing model was a VotingEnsemble algorithm (accuracy of 0.91739) resulting from an Azure AutoML run, which has performed better than the first one, trained through Azure HyperDrive on a LogisticRegression algorithm (accuracy of 0.9132).

## Scikit-learn Pipeline
**Explain the pipeline architecture, including data, hyperparameter tuning, and classification algorithm.**
- The first steps are generic, So mainly intialize the workspace and create a compute cluster for model training. Then prepare the data by creating a TabularDataset form the provided CSV file.

- The data was then cleaned, and split using the training script 'train.py'.

- The classifying algorithm used is logistic regression. It is used to estimate discrete values based on a set of independent variables.

- Next, SKLearn estimator was constructed. This estimator will provide a simple way of deploying the training job on the compute target.

- The last step is to provide the Sampling Parameter to run the hyperparameter tuning. The ranges for the inverse of the regularization strength and choices for maximum number of iterations to converge are provided.

- We configure the HyperDrive to set the 'Accuracy' as the primary metric.

- Finally sibmit the experiment and find the best model.

**What are the benefits of the parameter sampler you chose?**

- Random sampling supports discrete and continuous hyperparameters. It supports early termination of low-performance runs and thereby reducing computation costs and speedup up the exploration of the parameter space.

**What are the benefits of the early stopping policy you chose?**

- Bandit policy is based on slack factor and evaluation interval. Bandit terminates runs where the primary metric is not within the specified slack factor compared to the best performing run. Slack factor is the slack allowed with respect to the best performing training run.

## AutoML
**In 1-2 sentences, describe the model and hyperparameters generated by AutoML.**
- The best model generated by AutoML is a VotingEnsemble method with a pre-processing step that uses MaxAbsScaler as pre-processing step.
- The explanation of the VotingEnsemble including the top 5 influencing indexes
![alt text](https://github.com/ahmedkhammessi/nd00333_AZMLND_Optimizing_a_Pipeline_in_Azure-Starter_Files/blob/master/Explanation/VotingEnsemble_Explanation.PNG?raw=true)

```
Pipeline(memory=None,  
	steps=[('maxabsscaler', MaxAbsScaler(copy=True)),  
		('lightgbmclassifier',  
		 LightGBMClassifier(boosting_type='gbdt', class_weight=None,  
							colsample_bytree=1.0,  
							importance_type='split', learning_rate=0.1,  
							max_depth=-1, min_child_samples=20,  
							min_child_weight=0.001, min_split_gain=0.0,  
							n_estimators=100, n_jobs=1, num_leaves=31,  
							objective=None, random_state=None,  
							reg_alpha=0.0, reg_lambda=0.0, silent=True,  
							subsample=1.0, subsample_for_bin=200000,  
							subsample_freq=0, verbose=-10))],  
	verbose=False), '1': Pipeline(memory=None,  
	steps=[('maxabsscaler', MaxAbsScaler(copy=True)),  
		('xgboostclassifier',  
		 XGBoostClassifier(base_score=0.5, booster='gbtree',  
						   colsample_bylevel=1, colsample_bynode=1,  
						   colsample_bytree=1, gamma=0,  
						   learning_rate=0.1, max_delta_step=0,  
						   max_depth=3, min_child_weight=1, missing=nan,  
						   n_estimators=100, n_jobs=1, nthread=None,  
						   objective='binary:logistic', random_state=0,  
						   reg_alpha=0, reg_lambda=1,  
						   scale_pos_weight=1, seed=None, silent=None,  
						   subsample=1, tree_method='auto', verbose=-10,  
						   verbosity=0))],  
	verbose=False), '31': Pipeline(memory=None,  
	steps=[('standardscalerwrapper',  
		 <azureml.automl.runtime.shared.model_wrappers.StandardScalerWrapper object at 0x7f40700323c8>),  
		('xgboostclassifier',  
		 XGBoostClassifier(base_score=0.5, booster='gbtree',  
						   colsample_bylevel=1, colsample_bynode=1,  
						   colsample_bytree=0.7, eta=0.2, gamma=1,  
						   learning_rate=0.1, max_delta_step=0,  
						   max_depth=5, max_leaves=0,  
						   min_child_weight=1, missing=nan,  
						   n_estimators=25, n_jobs=1, nthread=None,  
						   objective='reg:logistic', random_state=0,  
						   reg_alpha=0, reg_lambda=1.1458333333333335,  
						   scale_pos_weight=1, seed=None, silent=None,  
						   subsample=1, tree_method='auto', verbose=-10,  
						   verbosity=0))],  
	verbose=False), '35': Pipeline(memory=None,  
	steps=[('sparsenormalizer',  
		 <azureml.automl.runtime.shared.model_wrappers.SparseNormalizer object at 0x7f3ee5c989b0>),  
		('lightgbmclassifier',  
		 LightGBMClassifier(boosting_type='gbdt', class_weight=None,  
							colsample_bytree=0.99,  
							importance_type='split',  
							learning_rate=0.05789894736842106,  
							max_bin=240, max_depth=10,  
							min_child_samples=2727, min_child_weight=2,  
							min_split_gain=0.21052631578947367,  
							n_estimators=400, n_jobs=1, num_leaves=197,  
							objective=None, random_state=None,  
							reg_alpha=0.5789473684210527,  
							reg_lambda=0.21052631578947367, silent=True,  
							subsample=0.09947368421052633,  
							subsample_for_bin=200000, subsample_freq=0,  
							verbose=-10))],  
	verbose=False), '28': Pipeline(memory=None,  
	steps=[('sparsenormalizer',  
		 <azureml.automl.runtime.shared.model_wrappers.SparseNormalizer object at 0x7f3ee5d2f630>),  
		('xgboostclassifier',  
		 XGBoostClassifier(base_score=0.5, booster='gbtree',  
						   colsample_bylevel=0.8, colsample_bynode=1,  
						   colsample_bytree=1, eta=0.3, gamma=0,  
						   learning_rate=0.1, max_delta_step=0,  
						   max_depth=7, max_leaves=31,  
						   min_child_weight=1, missing=nan,  
						   n_estimators=100, n_jobs=1, nthread=None,  
						   objective='reg:logistic', random_state=0,  
						   reg_alpha=1.4583333333333335,  
						   reg_lambda=0.20833333333333334,  
						   scale_pos_weight=1, seed=None, silent=None,  
						   subsample=1, tree_method='auto', verbose=-10,  
						   verbosity=0))],  
	verbose=False), '4': Pipeline(memory=None,  
	steps=[('maxabsscaler', MaxAbsScaler(copy=True)),  
		('sgdclassifierwrapper',  
		 SGDClassifierWrapper(alpha=9.59184081632653,  
							  class_weight='balanced', eta0=0.01,  
							  fit_intercept=True,  
							  l1_ratio=0.3877551020408163,  
							  learning_rate='invscaling', loss='log',  
							  max_iter=1000, n_jobs=1, penalty='none',  
							  power_t=0, random_state=None,  
							  tol=0.01))],  
	verbose=False), '36': Pipeline(memory=None,  
	steps=[('sparsenormalizer',  
		 <azureml.automl.runtime.shared.model_wrappers.SparseNormalizer object at 0x7f3ef5beec50>),  
		('xgboostclassifier',  
		 XGBoostClassifier(base_score=0.5, booster='gbtree',  
						   colsample_bylevel=1, colsample_bynode=1,  
						   colsample_bytree=0.6, eta=0.2, gamma=0,  
						   learning_rate=0.1, max_delta_step=0,  
						   max_depth=2, max_leaves=0,  
						   min_child_weight=1, missing=nan,  
						   n_estimators=100, n_jobs=1, nthread=None,  
						   objective='reg:logistic', random_state=0,  
						   reg_alpha=0, reg_lambda=1.0416666666666667,  
						   scale_pos_weight=1, seed=None, silent=None,  
						   subsample=0.9, tree_method='auto',  
						   verbose=-10, verbosity=0))],  
	verbose=False), '40': Pipeline(memory=None,  
	steps=[('maxabsscaler', MaxAbsScaler(copy=True)),  
		('lightgbmclassifier',  
		 LightGBMClassifier(boosting_type='goss', class_weight=None,  
							colsample_bytree=0.6933333333333332,  
							importance_type='split',  
							learning_rate=0.07368684210526316,  
							max_bin=380, max_depth=3,  
							min_child_samples=1591, min_child_weight=2,  
							min_split_gain=0.2631578947368421,  
							n_estimators=800, n_jobs=1, num_leaves=32,  
							objective=None, random_state=None,  
							reg_alpha=0.5263157894736842,  
							reg_lambda=0.5789473684210527, silent=True,  
							subsample=1, subsample_for_bin=200000,  
							subsample_freq=0, verbose=-10))],  
	verbose=False)
  ```
## Pipeline comparison
**Compare the two models and their performance. What are the differences in accuracy? In architecture? If there was a difference, why do you think there was one?**
- The Voting Ensemble model outperform the Logistic Regression one with an accuracy of 0.9181 against 0.9129.

The differences in architecture are huge:

- HyperDrive starts multiple runs each of which trains the LogisticRegression model using different tuples of hyper-parameters
- AutoML starts multiple runs each of which executes complex pipelines with choices of hyper-parameters, models and configuration details
## Future work
**What are some areas of improvement for future experiments? Why might these improvements help the model?**
- Adapt the imbalanced classes detected in the dataset.
- Increase the max_total_runs parameter of HyperDriveConfig
- Increase the experiment_timeout_minutes parameter of the AutoMLConfig
- We can improve the data cleaning by replacing the pdays variable with another boolean typed varible for a better performance and readability.
- Use different primary metric instead of Accuracy we can use AUC_weighted which is better suited for binary classification.
